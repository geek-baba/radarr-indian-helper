<!DOCTYPE html>
<html lang="en" class="<%= typeof theme !== 'undefined' && theme === 'dark' ? 'dark' : '' %>">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Dashboard — desiarr</title>
  <link rel="icon" type="image/svg+xml" href="/assets/desiarr-logo.svg">
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="/css/app.css">
  <style>
    @keyframes slideIn {
      from {
        transform: translateX(100%);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }
    @keyframes slideOut {
      from {
        transform: translateX(0);
        opacity: 1;
      }
      to {
        transform: translateX(100%);
        opacity: 0;
      }
    }
    .toast-enter {
      animation: slideIn 0.3s ease-out;
    }
    .toast-exit {
      animation: slideOut 0.3s ease-in;
    }
  </style>
</head>
<body class="bg-[var(--bg)] text-[var(--text)] min-h-screen">
  <!-- Toast Notification Container -->
  <div id="toastContainer" class="fixed top-4 right-4 z-50 space-y-2"></div>
  
  <%- include('partials/app-sidebar', { currentPage: 'dashboard' }) %>
  
  <div class="lg:pl-64">
    <%- include('partials/app-header', { lastRefresh: typeof lastRefresh !== 'undefined' ? lastRefresh : null }) %>
    
    <main class="p-4 lg:p-6">
      <% 
        // Define these variables for search functionality
        const hasNewMovies = newMoviesByPeriod && (
          (newMoviesByPeriod.today && newMoviesByPeriod.today.length > 0) ||
          (newMoviesByPeriod.yesterday && newMoviesByPeriod.yesterday.length > 0) ||
          (newMoviesByPeriod.older && newMoviesByPeriod.older.length > 0)
        );
        const hasExistingMovies = existingMoviesByPeriod && (
          (existingMoviesByPeriod.today && existingMoviesByPeriod.today.length > 0) ||
          (existingMoviesByPeriod.yesterday && existingMoviesByPeriod.yesterday.length > 0) ||
          (existingMoviesByPeriod.older && existingMoviesByPeriod.older.length > 0)
        );
        const hasUnmatched = unmatchedItems && unmatchedItems.length > 0;
      %>

      <% if (!hasNewMovies && !hasExistingMovies && !hasUnmatched) { %>
        <p class="text-gray-600 dark:text-gray-400">No releases found. Go to Settings to add RSS feeds and sync data.</p>
      <% } else { %>
        
        <!-- Top-level Tabs with Sync & Match Button - Modern Design -->
        <div class="mb-6">
          <nav class="flex gap-2 items-center flex-wrap" aria-label="Main Sections">
            <% 
              const mainTabs = [
                { key: 'new', label: 'New Movies', count: (newMoviesByPeriod.today?.length || 0) + (newMoviesByPeriod.yesterday?.length || 0) + (newMoviesByPeriod.older?.length || 0), visible: hasNewMovies },
                { key: 'existing', label: 'Existing Movies', count: (existingMoviesByPeriod.today?.length || 0) + (existingMoviesByPeriod.yesterday?.length || 0) + (existingMoviesByPeriod.older?.length || 0), visible: hasExistingMovies },
                { key: 'unmatched', label: 'Unmatched Items', count: unmatchedItems?.length || 0, visible: hasUnmatched },
              ];
              let firstVisibleTab = mainTabs.findIndex(tab => tab.visible);
              if (firstVisibleTab === -1) firstVisibleTab = 0;
            %>
            <% mainTabs.forEach((tab, index) => { %>
              <% if (tab.visible) { %>
                <button 
                  onclick="showMainSection('<%= tab.key %>')" 
                  id="main-tab-<%= tab.key %>"
                  class="<%= index === firstVisibleTab 
                    ? 'bg-blue-600 text-white shadow-md' 
                    : 'bg-gray-100 dark:bg-gray-800 text-gray-700 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-700' %> 
                    px-4 py-2.5 rounded-lg font-medium text-sm transition-all duration-200 flex items-center gap-2"
                >
                  <span><%= tab.label %></span>
                  <span class="<%= index === firstVisibleTab 
                    ? 'bg-blue-500 text-white' 
                    : 'bg-gray-300 dark:bg-gray-600 text-gray-700 dark:text-gray-300' %> 
                    px-2 py-0.5 rounded-full text-xs font-semibold min-w-[1.75rem] text-center">
                    <%= tab.count %>
                  </span>
                </button>
              <% } %>
            <% }); %>
            
            <!-- Sync & Match Button -->
            <div class="ml-auto flex items-center gap-3">
              <button 
                id="syncMatchBtn" 
                class="px-4 py-2.5 rounded-lg bg-blue-600 text-white hover:bg-blue-700 transition-colors font-medium text-sm disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-2"
                type="button"
              >
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
                </svg>
                <span id="syncMatchBtnText">Sync & Match</span>
              </button>
            </div>
          </nav>
          
          <!-- Progress Container (shown below tabs when active) -->
          <div id="syncProgressContainer" class="hidden mt-4 bg-white dark:bg-gray-800 rounded-lg shadow p-4">
            <div class="flex items-center justify-between mb-2">
              <div class="flex-1">
                <div class="bg-gray-200 dark:bg-gray-700 rounded-full h-2.5 mb-2">
                  <div id="syncProgressBar" class="bg-blue-500 h-2.5 rounded-full transition-all duration-300" style="width: 0%"></div>
                </div>
                <div id="syncProgressText" class="text-sm text-gray-700 dark:text-gray-300 font-medium"></div>
                <div id="syncProgressDetails" class="hidden mt-2 text-xs text-gray-600 dark:text-gray-400 space-y-1"></div>
                <div id="syncProgressError" class="hidden mt-2 p-3 bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg">
                  <div class="flex items-start justify-between gap-2">
                    <div class="flex-1">
                      <div class="text-sm font-medium text-red-800 dark:text-red-300 mb-1">Error</div>
                      <div id="syncProgressErrorText" class="text-sm text-red-700 dark:text-red-400"></div>
                    </div>
                    <button 
                      id="dismissErrorBtn"
                      onclick="dismissSyncError()"
                      class="text-red-600 dark:text-red-400 hover:text-red-800 dark:hover:text-red-200 flex-shrink-0"
                      aria-label="Dismiss error"
                    >
                      <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                      </svg>
                    </button>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- New Movies Section -->
        <% if (hasNewMovies) { %>
          <div id="main-section-new" class="main-section <%= firstVisibleTab === 0 ? '' : 'hidden' %>">
            <!-- Time Period Tabs for New Movies - Modern Design -->
            <div class="mb-4">
              <nav class="flex gap-2" aria-label="Time Periods">
                <% const newPeriods = [
                  { key: 'today', label: 'Today', count: newMoviesByPeriod.today?.length || 0 },
                  { key: 'yesterday', label: 'Yesterday', count: newMoviesByPeriod.yesterday?.length || 0 },
                  { key: 'older', label: 'Older', count: newMoviesByPeriod.older?.length || 0 }
                ]; %>
                <% 
                  let firstNewIndex = -1;
                  newPeriods.forEach((period, index) => {
                    if (period.count > 0 && firstNewIndex === -1) {
                      firstNewIndex = index;
                    }
                  });
                %>
                <% newPeriods.forEach((period, index) => { %>
                  <% if (period.count > 0) { %>
                    <button 
                      onclick="showNewMoviesPeriod('<%= period.key %>')" 
                      id="new-tab-<%= period.key %>"
                      class="<%= index === firstNewIndex 
                        ? 'bg-blue-100 dark:bg-blue-900/30 text-blue-700 dark:text-blue-300 border-2 border-blue-300 dark:border-blue-700' 
                        : 'bg-gray-50 dark:bg-gray-800/50 text-gray-600 dark:text-gray-400 border-2 border-transparent hover:bg-gray-100 dark:hover:bg-gray-700 hover:border-gray-200 dark:hover:border-gray-600' %> 
                        px-3 py-1.5 rounded-md font-medium text-xs transition-all duration-200 flex items-center gap-1.5"
                    >
                      <span><%= period.label %></span>
                      <span class="<%= index === firstNewIndex 
                        ? 'bg-blue-200 dark:bg-blue-800 text-blue-800 dark:text-blue-200' 
                        : 'bg-gray-200 dark:bg-gray-700 text-gray-600 dark:text-gray-400' %> 
                        px-1.5 py-0.5 rounded-full text-xs font-semibold min-w-[1.5rem] text-center">
                        <%= period.count %>
                      </span>
                    </button>
                  <% } %>
                <% }); %>
              </nav>
            </div>

            <!-- New Movies Time Period Sections -->
            <% newPeriods.forEach((period, index) => { %>
              <% if (newMoviesByPeriod[period.key] && newMoviesByPeriod[period.key].length > 0) { %>
                <div id="new-period-<%= period.key %>" class="new-movies-section <%= index === firstNewIndex ? '' : 'hidden' %>">
                  <% newMoviesByPeriod[period.key].forEach(movie => { %>
                    <%- include('partials/dashboard/movie-card', { movie, radarrBaseUrl }) %>
                  <% }); %>
                </div>
              <% } %>
            <% }); %>
          </div>
        <% } %>

        <!-- Existing Movies Section -->
        <% if (hasExistingMovies) { %>
          <div id="main-section-existing" class="main-section <%= firstVisibleTab === 1 ? '' : 'hidden' %>">
            <!-- Time Period Tabs for Existing Movies - Modern Design -->
            <div class="mb-4">
              <nav class="flex gap-2" aria-label="Time Periods">
                <% const existingPeriods = [
                  { key: 'today', label: 'Today', count: existingMoviesByPeriod.today?.length || 0 },
                  { key: 'yesterday', label: 'Yesterday', count: existingMoviesByPeriod.yesterday?.length || 0 },
                  { key: 'older', label: 'Older', count: existingMoviesByPeriod.older?.length || 0 }
                ]; %>
                <% 
                  let firstExistingIndex = -1;
                  existingPeriods.forEach((period, index) => {
                    if (period.count > 0 && firstExistingIndex === -1) {
                      firstExistingIndex = index;
                    }
                  });
                %>
                <% existingPeriods.forEach((period, index) => { %>
                  <% if (period.count > 0) { %>
                    <button 
                      onclick="showExistingMoviesPeriod('<%= period.key %>')" 
                      id="existing-tab-<%= period.key %>"
                      class="<%= index === firstExistingIndex 
                        ? 'bg-blue-100 dark:bg-blue-900/30 text-blue-700 dark:text-blue-300 border-2 border-blue-300 dark:border-blue-700' 
                        : 'bg-gray-50 dark:bg-gray-800/50 text-gray-600 dark:text-gray-400 border-2 border-transparent hover:bg-gray-100 dark:hover:bg-gray-700 hover:border-gray-200 dark:hover:border-gray-600' %> 
                        px-3 py-1.5 rounded-md font-medium text-xs transition-all duration-200 flex items-center gap-1.5"
                    >
                      <span><%= period.label %></span>
                      <span class="<%= index === firstExistingIndex 
                        ? 'bg-blue-200 dark:bg-blue-800 text-blue-800 dark:text-blue-200' 
                        : 'bg-gray-200 dark:bg-gray-700 text-gray-600 dark:text-gray-400' %> 
                        px-1.5 py-0.5 rounded-full text-xs font-semibold min-w-[1.5rem] text-center">
                        <%= period.count %>
                      </span>
                    </button>
                  <% } %>
                <% }); %>
              </nav>
            </div>

            <!-- Existing Movies Time Period Sections -->
            <% existingPeriods.forEach((period, index) => { %>
              <% if (existingMoviesByPeriod[period.key] && existingMoviesByPeriod[period.key].length > 0) { %>
                <div id="existing-period-<%= period.key %>" class="existing-movies-section <%= index === firstExistingIndex ? '' : 'hidden' %>">
                  <% existingMoviesByPeriod[period.key].forEach(movie => { %>
                    <%- include('partials/dashboard/movie-card', { movie, radarrBaseUrl }) %>
                  <% }); %>
                </div>
              <% } %>
            <% }); %>
          </div>
        <% } %>

        <!-- Unmatched Items Section -->
        <% if (hasUnmatched) { %>
        <div id="main-section-unmatched" class="main-section <%= firstVisibleTab === 2 ? '' : 'hidden' %>">
          <% unmatchedItems.forEach(movie => { %>
            <%- include('partials/dashboard/movie-card', { movie, radarrBaseUrl }) %>
          <% }); %>
        </div>
        <% } %>


      <% } %>
    </main>
  </div>

  <!-- Add Movie Modal -->
  <div id="addMovieModal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
    <div class="bg-white dark:bg-gray-800 rounded-lg p-6 max-w-md w-full">
      <h3 class="text-xl font-semibold mb-4 text-gray-900 dark:text-white">Add Movie to Radarr</h3>
      <form id="addMovieForm" onsubmit="submitAddMovie(event)">
        <input type="hidden" id="addMovieReleaseId" name="releaseId">
        <div class="mb-4">
          <label class="block text-sm font-medium mb-2 text-gray-700 dark:text-gray-300">Quality Profile:</label>
          <select id="qualityProfileSelect" name="qualityProfileId" required class="w-full border border-gray-300 dark:border-gray-600 rounded px-2 py-1 bg-white dark:bg-gray-700 text-gray-900 dark:text-gray-100">
            <option value="">Loading...</option>
          </select>
        </div>
        <div class="mb-4">
          <label class="block text-sm font-medium mb-2 text-gray-700 dark:text-gray-300">Root Folder:</label>
          <select id="rootFolderSelect" name="rootFolderPath" required class="w-full border border-gray-300 dark:border-gray-600 rounded px-2 py-1 bg-white dark:bg-gray-700 text-gray-900 dark:text-gray-100">
            <option value="">Loading...</option>
          </select>
        </div>
        <div class="flex justify-end space-x-2">
          <button type="button" onclick="hideAddMovieModal()" class="bg-gray-500 hover:bg-gray-600 text-white px-4 py-2 rounded">
            Cancel
          </button>
          <button type="submit" class="bg-green-500 hover:bg-green-600 text-white px-4 py-2 rounded">
            Add
          </button>
        </div>
      </form>
    </div>
  </div>

  <script src="/js/ui.js"></script>
  <script>
    // Toast Notification System
    function showToast(message, type = 'info', duration = 5000) {
      const container = document.getElementById('toastContainer');
      const toast = document.createElement('div');
      
      const bgColors = {
        success: 'bg-green-500',
        error: 'bg-red-500',
        warning: 'bg-yellow-500',
        info: 'bg-blue-500',
      };
      
      const icons = {
        success: '✓',
        error: '✕',
        warning: '⚠',
        info: 'ℹ',
      };
      
      toast.className = `${bgColors[type] || bgColors.info} text-white px-6 py-4 rounded-lg shadow-lg flex items-center space-x-3 min-w-[300px] max-w-md toast-enter`;
      toast.innerHTML = `
        <span class="text-xl font-bold">${icons[type] || icons.info}</span>
        <span class="flex-1">${message}</span>
        <button onclick="this.parentElement.remove()" class="text-white hover:text-gray-200 font-bold text-xl">&times;</button>
      `;
      
      container.appendChild(toast);
      
      setTimeout(() => {
        toast.classList.remove('toast-enter');
        toast.classList.add('toast-exit');
        setTimeout(() => toast.remove(), 300);
      }, duration);
    }

    // Confirmation Dialog System
    function showConfirm(message, onConfirm, onCancel = null) {
      const overlay = document.createElement('div');
      overlay.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
      overlay.innerHTML = `
        <div class="bg-white dark:bg-gray-800 rounded-lg p-6 max-w-md w-full mx-4 shadow-xl">
          <h3 class="text-lg font-semibold mb-4 text-gray-900 dark:text-white">Confirm</h3>
          <p class="text-gray-700 dark:text-gray-300 mb-6">${message}</p>
          <div class="flex justify-end space-x-3">
            <button class="cancel-btn bg-gray-500 hover:bg-gray-600 text-white px-4 py-2 rounded">
              Cancel
            </button>
            <button class="confirm-btn bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded">
              Confirm
            </button>
          </div>
        </div>
      `;
      
      document.body.appendChild(overlay);
      
      overlay.querySelector('.confirm-btn').addEventListener('click', () => {
        overlay.remove();
        if (onConfirm) onConfirm();
      });
      
      overlay.querySelector('.cancel-btn').addEventListener('click', () => {
        overlay.remove();
        if (onCancel) onCancel();
      });
      
      overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
          overlay.remove();
          if (onCancel) onCancel();
        }
      });
    }

    // Main section tab switching
    function showMainSection(section) {
      // Hide all main sections
      document.querySelectorAll('.main-section').forEach(section => {
        section.classList.add('hidden');
      });
      // Show selected section
      document.getElementById(`main-section-${section}`).classList.remove('hidden');
      
      // Update tab styles - Modern design with background colors
      document.querySelectorAll('[id^="main-tab-"]').forEach(tab => {
        tab.classList.remove('bg-blue-600', 'text-white', 'shadow-md');
        tab.classList.add('bg-gray-100', 'dark:bg-gray-800', 'text-gray-700', 'dark:text-gray-300');
        
        // Update badge styles
        const badge = tab.querySelector('span:last-child');
        if (badge) {
          badge.classList.remove('bg-blue-500', 'text-white');
          badge.classList.add('bg-gray-300', 'dark:bg-gray-600', 'text-gray-700', 'dark:text-gray-300');
        }
      });
      
      const activeTab = document.getElementById(`main-tab-${section}`);
      activeTab.classList.remove('bg-gray-100', 'dark:bg-gray-800', 'text-gray-700', 'dark:text-gray-300');
      activeTab.classList.add('bg-blue-600', 'text-white', 'shadow-md');
      
      // Update active badge
      const activeBadge = activeTab.querySelector('span:last-child');
      if (activeBadge) {
        activeBadge.classList.remove('bg-gray-300', 'dark:bg-gray-600', 'text-gray-700', 'dark:text-gray-300');
        activeBadge.classList.add('bg-blue-500', 'text-white');
      }
    }

    // Tab switching for New Movies
    function showNewMoviesPeriod(period) {
      // Hide all new movie sections
      document.querySelectorAll('.new-movies-section').forEach(section => {
        section.classList.add('hidden');
      });
      // Show selected section
      document.getElementById(`new-period-${period}`).classList.remove('hidden');
      
      // Update tab styles - Modern design with background colors
      document.querySelectorAll('[id^="new-tab-"]').forEach(tab => {
        tab.classList.remove('bg-blue-100', 'dark:bg-blue-900/30', 'text-blue-700', 'dark:text-blue-300', 'border-2', 'border-blue-300', 'dark:border-blue-700');
        tab.classList.add('bg-gray-50', 'dark:bg-gray-800/50', 'text-gray-600', 'dark:text-gray-400', 'border-transparent');
        
        // Update badge styles
        const badge = tab.querySelector('span:last-child');
        if (badge) {
          badge.classList.remove('bg-blue-200', 'dark:bg-blue-800', 'text-blue-800', 'dark:text-blue-200');
          badge.classList.add('bg-gray-200', 'dark:bg-gray-700', 'text-gray-600', 'dark:text-gray-400');
        }
      });
      
      const activeTab = document.getElementById(`new-tab-${period}`);
      activeTab.classList.remove('bg-gray-50', 'dark:bg-gray-800/50', 'text-gray-600', 'dark:text-gray-400', 'border-transparent');
      activeTab.classList.add('bg-blue-100', 'dark:bg-blue-900/30', 'text-blue-700', 'dark:text-blue-300', 'border-2', 'border-blue-300', 'dark:border-blue-700');
      
      // Update active badge
      const activeBadge = activeTab.querySelector('span:last-child');
      if (activeBadge) {
        activeBadge.classList.remove('bg-gray-200', 'dark:bg-gray-700', 'text-gray-600', 'dark:text-gray-400');
        activeBadge.classList.add('bg-blue-200', 'dark:bg-blue-800', 'text-blue-800', 'dark:text-blue-200');
      }
    }

    // Tab switching for Existing Movies
    function showExistingMoviesPeriod(period) {
      // Hide all existing movie sections
      document.querySelectorAll('.existing-movies-section').forEach(section => {
        section.classList.add('hidden');
      });
      // Show selected section
      document.getElementById(`existing-period-${period}`).classList.remove('hidden');
      
      // Update tab styles - Modern design with background colors
      document.querySelectorAll('[id^="existing-tab-"]').forEach(tab => {
        tab.classList.remove('bg-blue-100', 'dark:bg-blue-900/30', 'text-blue-700', 'dark:text-blue-300', 'border-2', 'border-blue-300', 'dark:border-blue-700');
        tab.classList.add('bg-gray-50', 'dark:bg-gray-800/50', 'text-gray-600', 'dark:text-gray-400', 'border-transparent');
        
        // Update badge styles
        const badge = tab.querySelector('span:last-child');
        if (badge) {
          badge.classList.remove('bg-blue-200', 'dark:bg-blue-800', 'text-blue-800', 'dark:text-blue-200');
          badge.classList.add('bg-gray-200', 'dark:bg-gray-700', 'text-gray-600', 'dark:text-gray-400');
        }
      });
      
      const activeTab = document.getElementById(`existing-tab-${period}`);
      activeTab.classList.remove('bg-gray-50', 'dark:bg-gray-800/50', 'text-gray-600', 'dark:text-gray-400', 'border-transparent');
      activeTab.classList.add('bg-blue-100', 'dark:bg-blue-900/30', 'text-blue-700', 'dark:text-blue-300', 'border-2', 'border-blue-300', 'dark:border-blue-700');
      
      // Update active badge
      const activeBadge = activeTab.querySelector('span:last-child');
      if (activeBadge) {
        activeBadge.classList.remove('bg-gray-200', 'dark:bg-gray-700', 'text-gray-600', 'dark:text-gray-400');
        activeBadge.classList.add('bg-blue-200', 'dark:bg-blue-800', 'text-blue-800', 'dark:text-blue-200');
      }
    }

    let currentReleaseId = null;
    let radarrOptions = null;

    async function loadRadarrOptions() {
      if (radarrOptions) return radarrOptions;
      
      try {
        const res = await fetch('/actions/radarr-options');
        const data = await res.json();
        if (data.success) {
          radarrOptions = data;
          return data;
        } else {
          throw new Error(data.error || 'Failed to load options');
        }
      } catch (error) {
        console.error('Error loading Radarr options:', error);
        showToast('Error loading Radarr options: ' + error.message, 'error');
        return null;
      }
    }

    async function addMovie(id) {
      currentReleaseId = id;
      
      const options = await loadRadarrOptions();
      if (!options) return;

      const qualitySelect = document.getElementById('qualityProfileSelect');
      qualitySelect.innerHTML = '';
      options.qualityProfiles.forEach(profile => {
        const option = document.createElement('option');
        option.value = profile.id;
        option.textContent = profile.name;
        qualitySelect.appendChild(option);
      });

      const rootFolderSelect = document.getElementById('rootFolderSelect');
      rootFolderSelect.innerHTML = '';
      options.rootFolders.forEach(folder => {
        const option = document.createElement('option');
        option.value = folder.path;
        option.textContent = folder.path;
        rootFolderSelect.appendChild(option);
      });

      document.getElementById('addMovieModal').classList.remove('hidden');
      document.getElementById('addMovieReleaseId').value = id;
    }

    function hideAddMovieModal() {
      document.getElementById('addMovieModal').classList.add('hidden');
      currentReleaseId = null;
    }

    async function submitAddMovie(event) {
      event.preventDefault();
      
      const releaseId = document.getElementById('addMovieReleaseId').value;
      const qualityProfileId = document.getElementById('qualityProfileSelect').value;
      const rootFolderPath = document.getElementById('rootFolderSelect').value;

      if (!qualityProfileId || !rootFolderPath) {
        showToast('Please select both quality profile and root folder', 'warning');
        return;
      }

      const submitBtn = event.target.querySelector('button[type="submit"]');
      const originalText = submitBtn.textContent;
      submitBtn.disabled = true;
      submitBtn.textContent = 'Adding...';

      try {
        const res = await fetch(`/actions/${releaseId}/add`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ qualityProfileId, rootFolderPath }),
        });
        const data = await res.json();
        if (data.success) {
          showToast(data.message || 'Movie added to Radarr!', 'success');
          hideAddMovieModal();
          setTimeout(() => location.reload(), 1500);
        } else {
          showToast('Error: ' + (data.error || 'Unknown error'), 'error');
          submitBtn.disabled = false;
          submitBtn.textContent = originalText;
        }
      } catch (error) {
        showToast('Error: ' + error.message, 'error');
        submitBtn.disabled = false;
        submitBtn.textContent = originalText;
      }
    }

    async function upgradeMovie(id) {
      showConfirm('Trigger upgrade search in Radarr?', async () => {
        try {
          const res = await fetch(`/actions/${id}/upgrade`, { method: 'POST' });
          const data = await res.json();
          if (data.success) {
            showToast(data.message || 'Upgrade search triggered!', 'success');
            setTimeout(() => location.reload(), 1500);
          } else {
            showToast('Error: ' + (data.error || 'Unknown error'), 'error');
          }
        } catch (error) {
          showToast('Error: ' + error.message, 'error');
        }
      });
    }

    async function ignoreRelease(id) {
      showConfirm('Ignore this release?', async () => {
        try {
          const res = await fetch(`/actions/${id}/ignore`, { method: 'POST' });
          const data = await res.json();
          if (data.success) {
            showToast('Release ignored successfully', 'success');
            setTimeout(() => location.reload(), 1500);
          } else {
            showToast('Error: ' + (data.error || 'Unknown error'), 'error');
          }
        } catch (error) {
          showToast('Error: ' + error.message, 'error');
        }
      });
    }

    let refreshInterval = null;

    async function refreshDashboard() {
      const refreshButton = document.getElementById('refreshButton');
      const progressContainer = document.getElementById('progressContainer');
      const progressBar = document.getElementById('progressBar');
      const progressText = document.getElementById('progressText');
      
      refreshButton.disabled = true;
      refreshButton.textContent = 'Refreshing...';
      progressContainer.classList.remove('hidden');
      
      try {
        const res = await fetch('/refresh', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
        });
        const data = await res.json();
        if (data.success) {
          showToast('Dashboard refresh started', 'success', 3000);
          // Start polling for progress
          refreshInterval = setInterval(pollRefreshProgress, 1000);
        } else {
          showToast('Failed to start refresh: ' + (data.message || 'Unknown error'), 'error');
          refreshButton.disabled = false;
          refreshButton.textContent = 'Refresh Dashboard';
          progressContainer.classList.add('hidden');
        }
      } catch (error) {
        showToast('Error: ' + error.message, 'error');
        refreshButton.disabled = false;
        refreshButton.textContent = 'Refresh Dashboard';
        progressContainer.classList.add('hidden');
      }
    }

    async function pollRefreshProgress() {
      try {
        const res = await fetch('/refresh/progress');
        const data = await res.json();
        
        const progressBar = document.getElementById('progressBar');
        const progressText = document.getElementById('progressText');
        const refreshButton = document.getElementById('refreshButton');
        const progressContainer = document.getElementById('progressContainer');
        
        if (data.isRunning) {
          const percent = data.total > 0 ? (data.current / data.total) * 100 : 0;
          progressBar.style.width = `${percent}%`;
          progressText.textContent = data.message || 'Processing...';
        } else {
          // Refresh complete
          clearInterval(refreshInterval);
          refreshInterval = null;
          progressBar.style.width = '100%';
          progressText.textContent = data.message || 'Complete';
          refreshButton.disabled = false;
          refreshButton.textContent = 'Refresh Dashboard';
          
          // Reload page after a short delay
          setTimeout(() => {
            location.reload();
          }, 2000);
        }
      } catch (error) {
        console.error('Error polling progress:', error);
        clearInterval(refreshInterval);
        refreshInterval = null;
      }
    }

    // Search functionality
    // Define and expose filterMovies to window immediately
    function filterMovies() {
      // Use global search from header
      const searchInput = document.getElementById('globalSearch');
      if (!searchInput) {
        return;
      }
      
      const clearSearchBtn = document.getElementById('clearSearchBtn');
      const searchResultsCount = document.getElementById('searchResultsCount');
      const query = searchInput.value.trim().toLowerCase();
      
      // Show/hide clear button
      if (query.length > 0) {
        if (clearSearchBtn) {
          clearSearchBtn.style.display = 'block';
          clearSearchBtn.classList.remove('hidden');
        }
      } else {
        if (clearSearchBtn) {
          clearSearchBtn.style.display = 'none';
          clearSearchBtn.classList.add('hidden');
        }
        if (searchResultsCount) {
          searchResultsCount.classList.add('hidden');
        }
        // Restore normal tab behavior - show all cards and restore tab visibility
        document.querySelectorAll('article.card[data-movie-id]').forEach(card => {
          card.style.display = '';
          card.classList.remove('hidden');
        });
        // Restore normal tab sections visibility
        document.querySelectorAll('.main-section').forEach(section => {
          section.classList.remove('hidden');
          section.style.display = '';
        });
        document.querySelectorAll('.new-movies-section, .existing-movies-section').forEach(section => {
          section.classList.remove('hidden');
          section.style.display = '';
        });
        return;
      }
      
      // When searching, show all main sections and time period sections so matching cards are visible
      // IMPORTANT: Remove hidden class AND set display to ensure visibility
      document.querySelectorAll('.main-section').forEach(section => {
        section.classList.remove('hidden');
        section.style.display = 'block';
      });
      document.querySelectorAll('.new-movies-section, .existing-movies-section').forEach(section => {
        section.classList.remove('hidden');
        section.style.display = 'block';
      });
      
      // Get all movie card containers
      const movieCards = document.querySelectorAll('article.card[data-movie-id]');
      let visibleCount = 0;
      
      movieCards.forEach(card => {
        const movieTitle = card.querySelector('h3')?.textContent?.toLowerCase() || '';
        const releaseRows = card.querySelectorAll('tbody tr');
        let hasMatchingRelease = false;
        
        // Check release titles and other release data
        releaseRows.forEach(row => {
          const releaseNameCell = row.querySelector('td:nth-child(2)');
          const releaseTitle = releaseNameCell?.textContent?.toLowerCase() || '';
          
          // Check feed name (source)
          const sourceCell = row.querySelector('td:nth-child(1)');
          const feedName = sourceCell?.textContent?.toLowerCase() || '';
          
          // Check if release title or feed name matches
          if (releaseTitle.includes(query) || feedName.includes(query)) {
            hasMatchingRelease = true;
          }
        });
        
        // Check all text content in the card for additional metadata (IMDB, TMDB links, etc.)
        const cardText = card.textContent?.toLowerCase() || '';
        
        // Check if movie title matches, any release matches, or any metadata matches
        const matches = movieTitle.includes(query) || hasMatchingRelease || cardText.includes(query);
        
        if (matches) {
          // Show card - remove hidden class AND set display
          card.classList.remove('hidden');
          card.style.display = 'block';
          visibleCount++;
        } else {
          // Hide card
          card.classList.add('hidden');
          card.style.display = 'none';
        }
      });
      
      // Update search results count
      if (searchResultsCount) {
        if (visibleCount === 0) {
          searchResultsCount.textContent = 'No movies found matching "' + searchInput.value + '"';
          searchResultsCount.classList.remove('hidden');
        } else {
          searchResultsCount.textContent = `Found ${visibleCount} movie${visibleCount !== 1 ? 's' : ''} matching "${searchInput.value}"`;
          searchResultsCount.classList.remove('hidden');
        }
      }
    }
    
    function clearSearch() {
      // Clear global search
      const globalSearch = document.getElementById('globalSearch');
      const searchResultsCount = document.getElementById('searchResultsCount');
      
      if (globalSearch) globalSearch.value = '';
      if (searchResultsCount) searchResultsCount.classList.add('hidden');
      clearSearchBtn.classList.add('hidden');
      searchResultsCount.classList.add('hidden');
      
      // Show all movie cards
      document.querySelectorAll('article.card[data-movie-id]').forEach(card => {
        card.style.display = '';
      });
      
      // Restore normal tab sections visibility (let the tab system handle it)
      document.querySelectorAll('.main-section').forEach(section => {
        section.style.display = '';
      });
      document.querySelectorAll('.new-movies-section, .existing-movies-section').forEach(section => {
        section.style.display = '';
      });
      
      // Restore the default tab view by triggering the active tab
      const activeMainTab = document.querySelector('[id^="main-tab-"].border-blue-500');
      if (activeMainTab) {
        const tabId = activeMainTab.id;
        const sectionKey = tabId.replace('main-tab-', '');
        showMainSection(sectionKey);
      }
    }
    
    function handleSearchKeydown(event) {
      // Clear search on Escape key
      if (event.key === 'Escape') {
        clearSearch();
        document.getElementById('searchInput').blur();
      }
    }
    
    // Format last refresh time in user's local timezone
    document.addEventListener('DOMContentLoaded', function() {
      const lastRefreshElement = document.getElementById('lastRefreshTime');
      if (lastRefreshElement && lastRefreshElement.dataset.utc) {
        const utcDate = new Date(lastRefreshElement.dataset.utc);
        // Format in user's local timezone with timezone info
        const options = {
          year: 'numeric',
          month: '2-digit',
          day: '2-digit',
          hour: '2-digit',
          minute: '2-digit',
          second: '2-digit',
          timeZoneName: 'short'
        };
        lastRefreshElement.textContent = utcDate.toLocaleString(undefined, options);
      }
    });

    // Copy-to-clipboard functionality for release links
    document.addEventListener('click', (e) => {
      const copyBtn = e.target.closest('.copy-link');
      if (!copyBtn) return;
      
      const url = copyBtn.dataset.url;
      const title = copyBtn.dataset.title;
      const textToCopy = url || title || '';
      
      if (textToCopy) {
        navigator.clipboard.writeText(textToCopy).then(() => {
          showToast('Copied to clipboard!', 'success', 2000);
        }).catch(() => {
          showToast('Failed to copy', 'error', 2000);
        });
      }
    });

    // Expose filterMovies to window immediately after definition
    window.filterMovies = filterMovies;

    // Sync & Match button functionality
    document.addEventListener('DOMContentLoaded', function() {
      const syncMatchBtn = document.getElementById('syncMatchBtn');
      const syncMatchBtnText = document.getElementById('syncMatchBtnText');
      const syncProgressContainer = document.getElementById('syncProgressContainer');
      const syncProgressBar = document.getElementById('syncProgressBar');
      const syncProgressText = document.getElementById('syncProgressText');
      const syncProgressDetails = document.getElementById('syncProgressDetails');
      const syncProgressError = document.getElementById('syncProgressError');
      const syncProgressErrorText = document.getElementById('syncProgressErrorText');
      let progressInterval = null;
      let errorTimeout = null;

      // Dismiss error function (exposed globally)
      window.dismissSyncError = function() {
        syncProgressError.classList.add('hidden');
        if (errorTimeout) {
          clearTimeout(errorTimeout);
          errorTimeout = null;
        }
        // If sync is not running, hide the entire progress container
        if (syncMatchBtn && !syncMatchBtn.disabled) {
          syncProgressContainer.classList.add('hidden');
        }
      };

      function showError(message, autoDismiss = true) {
        if (syncProgressErrorText) {
          syncProgressErrorText.textContent = message;
        }
        syncProgressError.classList.remove('hidden');
        
        // Auto-dismiss error after 10 seconds if enabled
        if (autoDismiss) {
          if (errorTimeout) {
            clearTimeout(errorTimeout);
          }
          errorTimeout = setTimeout(() => {
            window.dismissSyncError();
          }, 10000);
        }
      }

      function updateProgress() {
        fetch('/build-match/progress')
          .then(res => {
            if (!res.ok) {
              throw new Error(`HTTP error! status: ${res.status}`);
            }
            return res.json();
          })
          .then(data => {
            if (!data || !data.isRunning) {
              // Sync completed
              if (progressInterval) {
                clearInterval(progressInterval);
                progressInterval = null;
              }
              
              // Check if there was an error
              if (data && data.currentStep && data.currentStep.startsWith('Error:')) {
                syncMatchBtn.disabled = false;
                syncMatchBtnText.textContent = 'Sync & Match';
                showError(data.currentStep.replace('Error: ', ''), false); // Don't auto-dismiss errors
              } else {
                // Success
                syncMatchBtn.disabled = false;
                syncMatchBtnText.textContent = 'Sync & Match';
                syncProgressError.classList.add('hidden');
                
                // Show completion message
                if (data && (data.progress === 100 || !data.isRunning)) {
                  syncProgressText.textContent = 'Sync & Match completed successfully!';
                  setTimeout(() => {
                    syncProgressContainer.classList.add('hidden');
                    // Reload page to show updated data
                    window.location.reload();
                  }, 2000);
                } else {
                  // Completed but no progress data
                  syncProgressText.textContent = 'Sync & Match completed';
                  setTimeout(() => {
                    syncProgressContainer.classList.add('hidden');
                    window.location.reload();
                  }, 2000);
                }
              }
              return;
            }

            // Update progress display
            syncProgressContainer.classList.remove('hidden');
            syncProgressError.classList.add('hidden');
            if (errorTimeout) {
              clearTimeout(errorTimeout);
              errorTimeout = null;
            }
            
            syncProgressBar.style.width = `${data.progress || 0}%`;
            
            // Build detailed progress text
            let progressText = data.currentStep || 'Processing...';
            
            // Add step details
            if (data.type === 'full') {
              // Full sync cycle - show which step we're on
              if (data.currentStep.includes('RSS')) {
                progressText = `Step 1/3: Syncing RSS Feeds${data.total > 0 ? ` (${data.processed || 0}/${data.total} feeds)` : '...'}`;
              } else if (data.currentStep.includes('Radarr')) {
                progressText = `Step 2/3: Syncing Radarr Movies${data.total > 0 ? ` (${data.processed || 0}/${data.total} movies)` : '...'}`;
              } else if (data.currentStep.includes('matching') || data.currentStep.includes('Matching')) {
                progressText = `Step 3/3: Running Matching Engine${data.total > 0 ? ` (${data.processed || 0}/${data.total} items)` : '...'}`;
              }
            } else if (data.total > 0) {
              progressText += ` (${data.processed || 0}/${data.total})`;
            }
            
            // Add error count if any
            if (data.errors > 0) {
              progressText += ` - ${data.errors} error${data.errors > 1 ? 's' : ''}`;
            }
            
            syncProgressText.textContent = progressText;
            
            // Display details if available
            if (data.details && Array.isArray(data.details) && data.details.length > 0) {
              syncProgressDetails.classList.remove('hidden');
              syncProgressDetails.innerHTML = data.details.map(detail => 
                `<div class="flex items-center gap-1">
                  <svg class="w-3 h-3 text-green-500 flex-shrink-0" fill="currentColor" viewBox="0 0 20 20">
                    <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"/>
                  </svg>
                  <span>${detail}</span>
                </div>`
              ).join('');
            } else {
              syncProgressDetails.classList.add('hidden');
            }
          })
          .catch(error => {
            console.error('Error fetching progress:', error);
            // Only show error if sync is supposed to be running
            if (syncMatchBtn && syncMatchBtn.disabled) {
              showError(`Error fetching progress: ${error.message}. The sync may still be running in the background.`, false);
            }
          });
      }

      syncMatchBtn?.addEventListener('click', function() {
        if (syncMatchBtn.disabled) return;
        
        // Clear any existing intervals/timeouts
        if (progressInterval) {
          clearInterval(progressInterval);
          progressInterval = null;
        }
        if (errorTimeout) {
          clearTimeout(errorTimeout);
          errorTimeout = null;
        }
        
        // Disable button and show loading state
        syncMatchBtn.disabled = true;
        syncMatchBtnText.textContent = 'Starting...';
        syncProgressContainer.classList.remove('hidden');
        syncProgressError.classList.add('hidden');
        syncProgressDetails.classList.add('hidden');
        syncProgressBar.style.width = '0%';
        syncProgressText.textContent = 'Initializing sync...';

        // Start sync
        fetch('/build-match', { method: 'POST' })
          .then(res => {
            if (!res.ok) {
              throw new Error(`HTTP error! status: ${res.status}`);
            }
            return res.json();
          })
          .then(data => {
            if (data.success) {
              // Start polling for progress
              updateProgress();
              progressInterval = setInterval(updateProgress, 1000);
            } else {
              syncMatchBtn.disabled = false;
              syncMatchBtnText.textContent = 'Sync & Match';
              showError(data.message || 'Failed to start sync. Please check your configuration and try again.', false);
            }
          })
          .catch(error => {
            console.error('Error starting sync:', error);
            syncMatchBtn.disabled = false;
            syncMatchBtnText.textContent = 'Sync & Match';
            showError(`Failed to start sync: ${error.message}. Please check your network connection and try again.`, false);
          });
      });
    });
  </script>
</body>
</html>
